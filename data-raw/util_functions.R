

#' @title getsingle extracts a single number from an input line of characters
#'
#' @description getsingle splits up a text line and translates the first non-
#'     empty character string into a number.
#'
#' @param inline the line of text, usually taken after using readLines
#' @param sep the separator used to divide the numbers from descriptive text.
#'     defaults to a comma.
#'
#' @return a single number
#' @export
#'
#' @examples
#' \dontrun{
#' x <- "12.3 , this is a number"
#' y <- "21.3 # 22.3 # here are two numbers"
#' getsingle(x)
#' getsingle(y,sep="#")
#' }
getsingle <- function(inline,sep=",") {  # inline=dat[41]
  tmp <- unlist(strsplit(inline,sep))
  tmp <- gsub(" ","",tmp)
  tmp <- tmp[nchar(tmp) > 0]
  return(as.numeric(tmp[1]))
}

#' @title getvector  extracts a vector of numbers from a line of characters
#' 
#' @description getvector when reading in a csv file using readLines, 
#'     getvector extarcts a line of numbers from a specified line within
#'     the readLine object.This function works out how many numbers there
#'     are. If you wish to add a comment at the end of a vector of numbers
#'     it must be separated from tehm by the separator. e.g. a comma
#' @param indat the readLines object
#' @param locate the line number from which to extract the numbers
#' @param sep the separator between numbers, defaults to ","
#'
#' @return a vector of numbers
#' @export
#'
#' @examples
#' \dontrun{
#' x <- "12.3, 15.1, 8.7,10.3,  # this is a vector of numbers"
#' y <- "21.3 # 22.3 # 8.7 # 10.3 # here are four numbers"
#' getvector(x)
#' getvector(y,sep="#")
#' }
getvector <- function(indat,locate,sep=",") { # indat=dat; locate=pick+2;sep=","
  vect <- indat[locate]
  if (length(grep("\t",vect) > 0)) vect <- gsub("\t",sep,vect)
  vect <- unlist(strsplit(vect,sep))
  vect <- gsub(" ","",vect)
  vect1 <- vect
  vect <- suppressWarnings(as.numeric(vect))
  vect <- vect[nchar(vect) > 0]   
  if (!any(vect1 == "NA")) {
    vect <- vect[!is.na(vect)]
  }
  return(vect)
}



#' @title readdata reads in a standard format data file
#'
#' @description readdata reads in a standard format data file. An example of the
#'     standard format is generated by using the function dataTemplate, which
#'     generates an example datafile which can be used to demonstrate the
#'     methods present in datalowSA, or can be used as a template to edit and
#'     input a new or different dataset.
#'
#' @param filename the filename (including the full path if required) containing
#'     the data in the standard format.
#' @param property does the data include a table of length-at-age, maturity-at-
#'     age, weight-at-age, fecundity-at-age, and that kind of thing (see the
#'     standard format for a list of data.)
#' @param verbose Default = TRUE, which prints out details as data is read in.
#'
#' @return a list of three objects, fish includes the Year, Catch, CPUE, and SE
#'     of the CPUE, glb containing an array of biological properties that can
#'     be global, and props containing age, laa, waa, maa, sela.
#' @export
#'
#' @examples
#' \dontrun{
#' dataTemplate(filename="test.csv", title="A test of the functions")
#' ans <- readdata("test.csv",property=FALSE)
#' str(ans)
#' }             # filename="sardine.csv"; 
readdata <- function(filename,property=FALSE,verbose=TRUE) {  # property=FALSE; filename=paste0(datadir,"eastdeepwatershark.csv")
  dat <- readLines(filename)
  spsname <- scan(file=filename,skip=0,what=character(),nlines = 1,quiet=TRUE)
  spsname <- removeEmpty(gsub(",","",spsname))
  pick <- grep("RESILIENCE",dat)[1]
  resilience <- scan(file=filename,skip=pick,what=character(),nlines = 1,quiet=TRUE)
  resilience <- removeEmpty(gsub(",","",resilience))
  pick <- grep("NYRS",dat)[1] + 1
  nyrs <- getsingle(dat[pick])
  if (verbose) cat(spsname,"\n\n resilience = ",resilience,
                   "  Num Years = ",nyrs,"\n\n")
  # get the fishery data into as many columns as required
  pick <- grep("YEARS",dat)[1]
  columns <- tolower(removeEmpty(unlist(strsplit(dat[pick],","))))
  numcols <- length(columns)
  columns <- c("year",columns[2:numcols])
  skips <- pick:(pick+nyrs-1)
  fish <- as.data.frame(matrix(NA,nrow=nyrs,ncol=length(columns),
                               dimnames=list(1:nyrs,columns)))
  for (i in 1:nyrs) { # i = 1
    fish[i,] <- scan(file=filename,skip=skips[i],sep=",",nlines = 1,quiet=TRUE)[1:numcols]
  }
  if (verbose) {
    cat("fish \n\n")
    print(head(fish,10))
    cat("\n")
  }
  glb=list(resilience=resilience,spsname=spsname)
  pick <- grep("BIOLOGY",dat)[1] + 1
  if (is.na(pick)) {
    props <- NULL
  } else {
    maxage <- getsingle(dat[pick])
    M <- getsingle(dat[pick+1])
    Linf <- getsingle(dat[pick+2])
    K <- getsingle(dat[pick+3])
    t0 <- getsingle(dat[pick+4])
    Waa <- getsingle(dat[pick+5])
    Wab <- getsingle(dat[pick+6])
    M50a <- getsingle(dat[pick+7])
    deltaM <- getsingle(dat[pick+8])
    sela50 <- getsingle(dat[pick+9])
    deltaS <- getsingle(dat[pick+10])
    steep <- getsingle(dat[pick+11])
    R0 <- getsingle(dat[pick+12])
    ages <- 0:maxage
    nages <- length(ages)
    glb <- list(maxage=maxage,M=M,
                Linf=Linf, K=K, t0=t0,
                Waa=Waa, Wab=Wab,
                M50a=M50a, deltaM=deltaM,
                steep=steep,R0=R0,
                sela50=sela50, deltaS=deltaS,
                resilience=resilience,
                nages=nages,ages=ages,nyrs=nyrs,spsname=spsname)
    columns <- c("age","laa","waa","maa","sela","feca")
    props <- as.data.frame(matrix(NA,nrow=nages,ncol=length(columns),
                                  dimnames=list(ages,columns)))   
    if (property) {
      pick <- grep("PROPERTY",dat)[1] + 1
      for (i in 1:nages) {
        props[i,] <- getvector(dat,pick,sep=",") 
        pick <- pick + 1
      }
    } else {
      # now calculate the properties
      laa <- vB(c(Linf,K,t0),ages)
      waa <- (Waa * laa ^ Wab)/1000
      maa <- logist(M50a,deltaM,ages)
      sela <- logist(sela50,deltaS,ages)
      feca <- sela * waa
      props <- as.data.frame(cbind(ages,laa,waa,maa,sela,feca))
    }
  }
  if (verbose) { 
    cat("biology \n")
    print(unlist(glb))
    cat("\n properties \n")
    print(head(props,10))
  }
  #   dat <- readLines(filename)
  pick <- grep("AGE",dat)[1] + 1
  if (is.na(pick)) {
    agedata <- NULL
  } else {
    yrage <- getsingle(dat[pick])
    numsex <- getsingle(dat[(pick+1)])
    ages <- getvector(dat,(pick+2),sep=",")
    agemax <- max(ages)
    nage <- length(ages)
    naa <- matrix(0,nrow=(yrage*numsex),ncol=(nage+2))
    colnames(naa) <- c("year","sex",ages)
    pick <- pick+2  # i = 1
    for (i in 1:(yrage*numsex)) naa[i,] <- getvector(dat,(pick+i),sep=",")
    rownames(naa) <- naa[,1]
    agedata <- list(yrage=yrage,ages=ages,agemax=agemax,nage=nage,naa=naa)
  }
  pick <- grep("LENGTH",dat)[1] + 1
  if (is.na(pick)) {
    lendata <- NULL
  } else {
    yrlen <- getsingle(dat[pick])
    numsexl <- getsingle(dat[(pick+1)])
    lengths <- getvector(dat,(pick+2),sep=",")
    maxlen <- max(lengths)
    nlength <- length(lengths)
    if (verbose) {
      cat("Number of years of Data: ",yrlen,"\n")
      cat("Number of sexes with Data: ",numsexl,"\n")
      cat("Length classes: ",lengths,"\n")
      cat("Number of length classes ",nlength,"\n")
    }
    nal <- matrix(0,nrow=(yrlen*numsexl),ncol=(nlength+2))
    colnames(nal) <- c("year","sex",lengths)
    pick <- pick+2
    for (i in 1:(yrlen*numsexl)) nal[i,] <- getvector(dat,(pick+i),sep=",")
    rownames(nal) <- nal[,1]
    
    lendata <- list(yrlen=yrlen,lengths=lengths,maxlen=maxlen,
                    nlength=nlength,nal=nal)
  }
  ans <- list(fish=fish,glb=glb,props=props,agedata=agedata,lendata=lendata)
  return(ans)
} # end of readdata


#' @title vB calculates the predicted von Bertalanffy length at age
#'
#' @description vB calculates length at age for the von Bertalanffy curve.
#'
#' @param par is a vector the first three cells of which are Linf, K, and t0
#'    for the VB curve; the fourth parameter will be sigma, the standard
#'    deviation of the normal likelihoods used with the residuals
#' @param ages is a vector of ages
#'
#' @return a vector of predicted lengths for the vector of ages in 'ages'
#' @export
#'
#' @examples
#' ages <- seq(0,20,1)
#' pars <- c(Linf=50,K=0.3,t0=-1.0,sigma=1.0) # Linf, K, t0, sigma
#' cbind(ages,vB(pars,ages))
vB <- function(par,ages) {
  return(par[1] * (1 - exp(-par[2]*(ages-par[3]))))
}
